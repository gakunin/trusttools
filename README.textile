h1. GakuNin Trust Tools

 *GakuNin Trust Tools* は，学術認証フェデレーション(学認)において，Web
ブラウザへの機能組み込みを用いることで，学認の利便性の向上を目指すプロ
ジェクトです．現時点では以下の機能の実現を目指しています．

* *サーバ証明書検証機能*

Identity Provider (IdP) および Service Provider (SP) のサイトのサーバ証
明書を学認が提供する仕組みで検証するためのツールです．ブラウザでアクセ
スしたサイトが学認加盟機関が提供するサイトかどうかを確認できるようにな
ります．

* *Default IdP 設定機能*

Discovery Service では，最初にログインした際にユーザは自身のアカウント
が登録されているIdPを選択する必要があります．しかし，IdPの選択はユーザに
とって必ずしも容易な手続きではありません．本機能を用いることで，
Default IdP を設定し，ユーザをIdP選択の手間から開放できます．

* *IdP 自動リダイレクト機能*

複数のフェデレーションに所属するSPでは，独自のDiscovery Serviceを利用し
ている場合があります．初めてこのようなサイトを利用したユーザには，正し
く自身のIdPを選択できない可能性があります．本機能を用いることで，ユーザ
はSPのログインURL をクリックしただけで適切なIdPにリダイレクトされます．

* *サーバ・クライアント相互認証機能* (提供予定)

現状の学認フェデレーションにおいて，IdPにおけるユーザ認証を安全に実施す
る手段としては，ICカードや携帯電話を用いた複数要素認証があげられます．
しかしながら，コスト面や運用上の問題により，必ずしもすべての組織におい
てこれらの機能が導入できるとは限りません．Webブラウザ拡張機能を安全に配
布することができれば，ブラウザに安全なクライアント・サーバ相互認証機能
を追加することができます．安全なクライアント・サーバ相互認証を用いれば，
パスワードをサーバ側に渡すことなく，また，サーバが正しいものであること
が確認できたときだけユーザをログインさせることができます．これにより個
人情報を不正なサイトに受け渡す危険性を低減できます．本機能では，PAKEを
用いた安全な相互認証機能を提供します．


GakuNin Trust Tools の有用性は，学認フェデレーション参加機関の皆様の協
力により，「安全に」「信頼できる」形でブラウザの拡張機能を配布すること
が可能かどうかに依存しています．まずは，Webブラウザの拡張機能により実現
できる機能の有用性についてご確認いただき，その中で拡張機能の配布可否に
ついて検証していければと考えています．現段階ではまだベータバージョンで
すが，皆様のご利用，フィードバックをお待ちしています．

h2. GakuNin Trust Tools の利用方法 (エンドユーザ用)

準備中 (FIXME)

h2. GakuNin Trust Tools の利用方法 (フェデレーション加入機関用)

GakuNin Trust Tools は以下のURIで配布されています．

https://test-ds.gakunin.nii.ac.jp/trusttools/

GakuNin Trusttool ではデフォルトの IdP を設定することが可能ですが，ユー
ザ自身がデフォルト値を設定するのは難しいと考えられます．そこで，本プロ
ジェクトでは，学認メタデータに登録されている IdP ごとにDefault IdP を設
定した拡張機能のパッケージを生成して，配布しています．

https://test-ds.gakunin.nii.ac.jp/trusttools/trusttools.ドメイン名.xpi

例)<br/>
https://test-ds.gakunin.nii.ac.jp/trusttools/trusttools.idp.nii.ac.jp.xpi

このURIを各参加組織のエンドユーザにご案内いただき，ご利用いただくこと
になります．なお，パッケージ自体に学認による署名が施されているため，各
組織のサーバにダウンロードして配布していただくことも可能です．

また，IdP/SPのサーバ証明書の検証，SPごとの自動リダイレクト処理等，
IdP/SPの情報を記載したProviderリストは，以下のURIで配布しています．

https://test-ds.gakunin.nii.ac.jp/trusttools/providers.json


h2. GakuNin Trust Tools の利用方法 (Trust Tools システム開発者用)

GakuNin Trust Tools の最新のソースコードは以下で公開されています．

https://github.com/gakunin/trusttools

以下では，配布されたコードからセットアップする手順を示します．なおコマ
ンドの実行例では，学認のテスト用フェデレーションでセットアップした場合，
および，テストIdP/SP/DSサーバを用いてローカルに動作確認する場合について
示します．なお，テストIdP/SP/DSサーバはすべて同じサーバで起動しているも
のとします．

学認IdP (ユーザがこのIdPを利用すると想定)<br/>
ホスト名: @idp.gakunin.nii.ac.jp@<br/>
@entityID@: https://idp.gakunin.nii.ac.jp/idp/<br/>

学認DS<br/>
ホスト名: @ds.gakunin.nii.ac.jp@<br/>

テストIdP/SP/DSサーバ<br/>
ホスト名: @gakunin.example.com@<br/>
@entityID@:<br/>
  IdP: https://gakunin.example.com/idp/<br/>
  SP: https://gakunin.example.com/sp/<br/>

とします．

h3. GakuNin Trust Tools セットアップの流れ

基本的には署名された「Providerリスト」および「ブラウザ拡張機能」をWeb上
に公開すればセットアップは完了です．

* *Providerリストの公開*

# メタデータから必要な情報の取得し，自動ログインに必要な情報の追加して「Providerリストデータ」を生成 (conv_metadata.rb)
# サーバ証明書を取得し，「Providerリスト」を生成して署名 (getservercert.pl)
# 「Providerリスト」ファイルの公開

* *ブラウザ拡張機能の公開*

# 最新のコードを checkout し，署名済みブラウザ拡張機能を生成
# 署名済みブラウザ拡張機能の公開

h4. Gakunin Trust Tools のチェックアウト

h4. 1. Network Security Service (NSS) のインストール

署名済みブラウザの拡張機能を生成するには，Mozilla プロジェクトが配布し
ている Network Security Service (NSS) ライブラリの certutil および
pk12util コマンドを利用する必要があります．例えば MacOS X では，
MacPorts を用いることで導入できます．

<code>
% sudo port install nss
</code>

MacPorts でインストールしたコマンド名は nss-certutil, nss-pk12util の
ように，頭に nss- がつきます．MacOS X を利用される場合は，以下のドキュ
メントを適宜読み替えてご参照ください．

h4. 2. 最新のコードを checkout し，署名済みブラウザ拡張機能を生成

Trust Tools の最新コードは以下のサイトで配布されています．

https://github.com/gakunin/trusttools

以下のコマンドでソースコードを checkout します．

<code>
% git clone git://github.com/gakunin/trusttools.git
% cd trusttools
</code>

すでに checkout している場合は，該当のディレクトリで以下のコマンドを実
行することで，最新のコードにアップデートできます．

<code>
% git pull
</code>

以上のような手順で checkout します．以下ではチェックアウトしたコマンド
群，および，拡張機能のソースコードを用いて，署名付きProviderリストおよ
びブラウザ拡張機能の作成方法を示します．

h4. Providerリストの公開

h4. 1. メタデータから必要な情報の取得し，自動ログインに必要な情報の追加してProviderリストデータを生成 (conv_metadata.rb)

Providerリストには，IdP, SP の証明書を検証するための情報が記載されます．
Providerリスト生成に必要な情報(Providerリストデータ)をあらかじめテキス
トファイルで準備する必要がありますが，基本的な情報はメタデータファイル
から自動的に生成できます．

メタデータファイルを @gakunin-metadata.xml@，自動リダイレクト時のパター
ンを指定した設定ファイルを @pattern_map.yml@ とすると，以下の
@conv_metadata.rb@ コマンドでProviderリストデータを生成します．

<code>
% ruby ./script/conv_metadata.rb metadata.xml pattern_map.yml > providers_data.csv
</code>

* @metadata.xml@: フェデレーションのメタデータファイル
* @pattern_map.xml@: 以下で説明

@pattern_map.yml@ は以下のような書式で作成します．

<code>
entity_id:
  login_prefix_uri: uri
  pattern_name: pn1
  cookie_flag: 1
</code>

自動リダイレクトを設定したいSPのEntityIDを指定し，必要なオプションを指
定します．オプションを指定しない場合はデフォルト値が利用されます．オプ
ションはそれぞれ以下のような意味をもっています．

* @login_prefix_uri@: このURIにマッチした場合，@pattern_name@ に指定し
  た処理を実行します．基本的には，@mod_shib/shibd@ で保護された URI を
  指定することになります．指定するURIが限定されていない場合，不要にリダ
  イレクトが発生する可能性があります．

* @pattern_name@: Providerリスト生成時に指定する @pattern_script@ 内に
  記述したリダイレクト処理の名称を指定します．

* @cookie_flag@: SPにおいて，コンテンツの保護にはアプリケーションの認証
  を用いており，@mod_shib/shibd@ によって保護されるURIがログイン時の
  URIに限定されている場合，認証後に保護されたコンテンツにアクセスする際
  には@login_prefix_uri@ で指定したURIにはアクセスしないため，再度リダ
  イレクトされることはありません．しかし，@mod_shib/shibd@ 自身によって
  コンテンツを保護している場合，コンテンツにアクセスした際にもリダイレ
  クトが発生する可能性があります．このフラグを 1 に設定することで，10分
  間再リダイレクトの発生を抑制できます．なお，@mod_shib/shibd@ は認証後
  に認証が完了していることを示す Cookie を設定するため，今後この
  Cookie を用いてリダイレクトを抑制する機能を提供する予定です．

なお，@login_prefix_uri@ および @pattern_name@ を省略した場合は，
Providerリストデータ上でも省略され，自動リダイレクトは実行されません．
以下は @pattern_map.yml@ の作成例です．

<code>
% cp ./config/pattern_map_sample.yml ./config/pattern_map.yml
% vi ./config/pattern_map.yml
https://scauth.scopus.com/:
  login_prefix_uri: www.scopus.com/standard/institutionLogin.url
  pattern_name: pn1
https://sdauth.sciencedirect.com/:
  login_prefix_uri: www.sciencedirect.com/science
  pattern_name: pn1
  cookie_flag: 1
</code>

YAML 形式の詳細については以下のドキュメントを御参照ください．

プログラマーのための YAML 入門 (初級編)
http://jp.rubyist.net/magazine/?0009-YAML

以下 @conv_metadata.rb@ の実行例です．

<code>
% mkdir files
% cd files
% curl -O https://metadata.gakunin.nii.ac.jp/gakunin-metadata.xml
% cd ..
% ruby ./script/conv_metadata.rb -m ./files/gakunin-metadata.xml -p pattern_map.yml > ./files/providers_data.csv
</code>

h4. 2. サーバ証明書を取得し，Providerリストを生成して署名 (getservercert.pl)

1 で生成したProviderリストデータからエンドユーザに配布するProviderリス
トを生成します．Providerリストには，各IdP，SPのサーバ証明書を含める必要
がありますが，現時点の実装ではネットワーク経由でサーバ証明書を取得しま
す．本来は，これらの証明書が本当にそのサイトで利用されているサーバ証明
書かどうかを検証する必要があるため，将来的には学認申請システムから取得
することを考えています．

Providerリストの生成には @getservercert.pl@ コマンドを利用します．

<code>
% perl ./script/getservercert.pl providers_data.csv private_key cert_uri pattern_script.js [ca_certs]
</code>

@getservercert.pl@ を利用するには，CPAN で JSON モジュールをインストール
しておく必要があります．
<code>
% cpan
cpan> install JSON
</code>

@getservercert.pl@ の引数はそれぞれ以下のようなものを指定します．

* @providers_data.csv@: Providerリストデータ
* @private_key@: Providerリスト署名用の秘密鍵
* @cert_uri@: Providerリスト署名用の秘密鍵に対する証明書 (公開鍵) を公開するURI
* @pattern_script.js@: 自動リダイレクトパターンを記述した JavaScript ファイル
* @ca_certs@: @getservercert.pl@ 実行時にサーバ証明書の検証も実施する場合に指
  定する証明書ディレクトリ

一般的な認証局証明書を含む @ca_certs@ ディレクトリを生成する方法としては，
例えば，Firefox において Export All Certificate Add-on を利用して証明書
をExport し，@conv_certs.rb@ (add reference, FIXME) で変換するといった
方法で生成できます．Export All Certificate Add-on で DER 形式の証明書を
Export したディレクトリを @der_certs@，PEM 形式の証明書の出力先を
@certs@ とすると，

<code>
% ./script/conv_certs.rb der_certs certs
</code>

で @certs@ ディレクトリを生成できます．

ProviderリストはJSON Simple Sign をベースとしたフォーマットを採用してい
ます．

JSON Simple Sign 1.0 draft 01
http://jsonenc.info/jss/1.0/

現在 JSON Web Signature のドラフトが提出されたことから，今後標準的に利
用されるフォーマットが変更される可能性もあります．今後注視していく必要
があります．

JSON Web Signature (JWS)
http://tools.ietf.org/html/draft-jones-json-web-signature-03

以下，学認DSの場合の実行例です．

<code>
% perl ./script/getservercert.pl ./files/providers_data.csv ./config/object_signing_key.pem https://ds.gakunin.nii.ac.jp/trusttools/object_signing_cert.pem ./config/pattern_script.js ./certs > ./files/providers.json
</code>

テスト環境の場合の実行例です．

<code>
% perl ./script/getservercert.pl ./files/providers_data.csv ./config/object_signing_key.pem https://gakunin.example.com/trusttools/object_signing_cert.pem ./config/pattern_script.js ./certs > ./files/providers.json
</code>

h4. 3. Providerリストの公開

2 でProviderリストを生成したら，適当なWebサーバにおいてProviderリストお
よびProviderリスト署名用証明書を公開します．Providerリストは各サーバの
最新状態を反映する必要があるため，定期的に更新するのが望ましいと考えら
れます．理想的にはProviderの登録システムにおいて，証明書の更新が登録さ
れたタイミング，あるいは，サーバでの証明書更新が検知されたタイミングで，
リアルタイムに反映することが望ましいですが，許容できる更新遅延を検討し，
定期的にスクリプト等で更新する方法が運用しやすいと考えられます．例えば，
@cron@ や @launchd@ を用いて定期的にProviderリストを再生成し，SSH の公
開鍵認証を用いて定期的に指定したサーバにアップロードするといった方法が
考えられます．以下の図は，自動でProviderリスト更新を実現する場合のシス
テム構成例を示しています．署名を実行するマシンは，インターネットから直
接アクセスできないセグメントに設置し，そこから署名済みのProviderリスト
をアップロードするのが望ましいと考えられます．

以下では @cron@ を用いて定期的にProviderリストをアップデートする例につ
いて示します．

簡単のため，ProviderリストをWebサーバの @DocumentRoot/trusttools/@ で公
開するものとし，サーバ側の @DocumentRoot@ のディレクトリを
@/var/www/html@ とします．また，Trust Tools を clone したディレクトリ
のフルパスを @#{root}@ とします．@cron@ ではファイルのパス名をフル
パスで指定する必要があります．

学認DSで公開する場合
<code>
% ruby #{root}/script/conv_metadata.rb #{root}/files/gakunin-metadata.xml #{root}/config/pattern_map.yml > #{root}/files/providers_data.csv
% perl #{root}/script/getservercert.pl #{root}/files/providers_data.csv #{root}/config/object_signing_key.pem https://ds.gakunin.nii.ac.jp/trusttools/object_signing_cert.pem #{root}/config/pattern_script.js #{root}/certs > #{root}/files/providers.json
% scp #{root}/config/object_signing_cert.pem username@ds.gakunin.nii.ac.jp:/var/www/html/trusttools/object_signing_cert.pem
% scp #{root}/files/providers.json username@ds.gakunin.nii.ac.jp:/var/www/html/trusttools/
</code>

テストDSで公開する場合
<code>
% ruby #{root}/script/conv_metadata.rb #{root}/files/metadata.xml #{root}/config/pattern_map.yml > #{root}/files/providers_data.csv
% perl #{root}/script/getservercert.pl #{root}/files/providers_data.csv #{root}/config/object_signing_key.pem https://gakunin.example.com/trusttools/object_signing_cert.pem #{root}/config/pattern_script.js #{root}/certs > #{root}/files/providers.json
% scp #{root}/config/object_signing_cert.pem username@gakunin.example.com:/var/www/html/trusttools/object_signing_cert.pem
% scp #{root}/files/providers.json username@gakunin.example.com:/var/www/html/trusttools/
</code>

というコマンドを実行することになります．ただし，SSH は公開鍵によりパス
フレーズなしで認証可能にしておく必要があります．

次に，このコマンドを @crontab@ に記述することになりますが，Ruby の
@whenever@ を用いると比較的簡単に記述することができます．@whenever@ は
RubyGems でインストールできます．

<code>
% gem install whenever
</code>

Trust Tools のディレクトリで @wheneverize@ コマンドを用いて
@config/schedule.rb@ を作成します．@config/schedule.rb@ を修正した後，
@whenever@ コマンドを実行すると，@crontab@ の文法で出力してくれます．問
題なければ，@-w@ オプションをつけて実行すれば，@crontab@ に書き込まれま
す．Trust Tools では @config/schedule_sample.rb@ というテンプレートファ
イルも用意しているので，こちらもご利用ください．

<code>
% wheneverize
% vi config/schedule.rb
root = File.expand_path("../../", __FILE__)
every 1.days do
  set :output, :standard
  command "ruby #{root}/script/conv_metadata.rb #{root}/files/metadata.xml #{root}/config/pattern_map.yml > #{root}/files/providers_data.csv"
  set :output, "#{root}/log/cron_log.log"
  command "perl #{root}/script/getservercert.pl #{root}/files/providers_data.csv #{root}/config/object_signing_key.pem https://gakunin.example.com/trusttools/object_signing_cert.pem #{root}/config/pattern_script.js #{root}/certs > #{root}/files/providers.json"
  command "scp #{root}/config/object_signing_cert.pem username@gakunin.example.com:/var/www/html/trusttools/object_signing_cert.pem"
  command "scp #{root}/files/providers.json username@gakunin.example.com:/var/www/html/trusttools/"
end
% whenever
0 0 * * * /bin/bash -l -c 'ruby /Users/akiyama/Documents/devel/projects/trusttools/script/conv_metadata.rb /Users/akiyama/Documents/devel/projects/trusttools/files/metadata.xml /Users/akiyama/Documents/devel/projects/trusttools/config/pattern_map.yml > /Users/akiyama/Documents/devel/projects/trusttools/files/providers_data.csv'

0 0 * * * /bin/bash -l -c 'perl /Users/akiyama/Documents/devel/projects/trusttools/script/getservercert.pl /Users/akiyama/Documents/devel/projects/trusttools/files/providers_data.csv /Users/akiyama/Documents/devel/projects/trusttools/config/object_signing_key.pem https://gakunin.example.com/trusttools/object_signing_cert.pem /Users/akiyama/Documents/devel/projects/trusttools/config/pattern_script.js /Users/akiyama/Documents/devel/projects/trusttools/certs > /Users/akiyama/Documents/devel/projects/trusttools/files/providers.json'

0 0 * * * /bin/bash -l -c 'scp /Users/akiyama/Documents/devel/projects/trusttools/config/object_signing_cert.pem username@gakunin.example.com:/var/www/html/trusttools/object_signing_cert.pem >> /Users/akiyama/Documents/devel/projects/trusttools/log/cron_log.log 2>&1'

0 0 * * * /bin/bash -l -c 'scp /Users/akiyama/Documents/devel/projects/trusttools/files/providers.json username@gakunin.example.com:/var/www/html/trusttools/ >> /Users/akiyama/Documents/devel/projects/trusttools/log/cron_log.log 2>&1'

## [message] Above is your schedule file converted to cron syntax; your crontab file was not updated.
## [message] Run `whenever --help' for more options.

% whenever -w
</code>

h4. ブラウザ拡張機能の公開

ブラウザ拡張機能は自由にブラウザの機能を拡張できますが，一方で悪意のあ
る拡張機能をインストールすることで，個人情報漏洩などの被害にあう可能性
があります．そのため，ユーザに対し拡張機能の信頼性を確認する手段を提供
し，安全に拡張機能を配布する必要があります．Trust Tools では，まず最低
限の確認機能として，拡張機能に電子署名を施すことを想定しています．以下
ではその方法について示します．

h5. 単一の組織用に署名済みブラウザ拡張機能を生成する方法

Trust Tools では署名済みブラウザ拡張機能を生成するためのスクリプト
@signxpi.sh@ を提供しています．@signxpi.sh@ のコマンドラインでの利用方
法は以下のようになっています．

<code>
% ./script/signxpi.sh keystore_path xpi_file_prefix xpi_path providers_uri idp_entity_id idp_cookie_name_for_ds ds_domainname
</code>

* @keystore_path@: Firefox の @keystore@ のパス名です．@keystore@ は後
  述の手順で作成します．

* @xpi_file_prefix@: 生成する署名済みブラウザ拡張機能 (XPI ファイル) の
  プレフィックスです．

* @xpi_path@: 生成する署名済みブラウザ拡張機能 (XPI ファイル) のソース
  コードのパスです．

* @providers_uri@: ブラウザ拡張機能にProviderリストを配布するURIを事前
  に埋め込むことで，ユーザが設定しなくても自動的に最新のProviderリスト
  をダウンロードできるようになります．ここでは，デフォルトのProvider リ
  ストの配布URIを指定します．

* @idp_entity_id@: 特定組織が配布するブラウザ拡張機能に，デフォルトでそ
  の組織が標準的に利用するIdPのEntityIDを指定しておくことで，ユーザが設
  定しなくても自動的にIdP選択させることが可能になります．ここではデフォ
  ルトで選択するIdPのEntityIDを指定します．

* @idp_cookie_name_for_ds@: Discovery Service (DS) にアクセスした際に，
  自動的に @idp_entity_id@ で指定したIdPを選択します．実際には，このパ
  ラメータで指定した名前のCookieにIdPのEntityIDを設定します (Cookie ヘッ
  ダとしてDSサーバに提示します)．DSは，このCookieの値を参照して，IdPを
  選択します．

* @ds_domainname@: @idp_cookie_name_for_ds@ で設定した Cookie を提示す
  るドメインを指定します．例えば，自身が参加するフェデレーションで用い
  られているDS のサーバ名を指定しておきます．

@keystore@ の生成方法は以下のページで紹介されています．

拡張機能への署名
https://developer.mozilla.org/ja/Signing_an_extension

以下上記のページに従って，@keystore@ の作成手順および証明書のインポート
方法を紹介します．@certutil@ では大文字オプションでコマンドを指定し，小
文字オプションでコマンドごとのオプションを指定します．

<code>
コマンド一覧
% certutil -h
コマンドのオプション確認
% certutil -H -L
</code>

上記のページに書かれている手順どおり，@certutil@ で空の証明書ストアを作
成する．

<code>
% mkdir keystore
% cd keystore
% certutil -N -d .
Enter a password which will be used to encrypt your keys.
The password should be at least 8 characters long,
and should contain at least one non-alphabetic character.

Enter new password:
</code>

自動実行を可能にするため，ここで設定したパスワードを @signxpi.sh@ に記
述します．パスワード設定前の @signxpi.sh@ は，@signxpi_sample.sh@ とい
う名前になっています．

<code>
% cp ./script/signxpi_sample.sh ./script/signxpi.sh
% vi ./script/signxpi.sh
password=inputted_password
</code>

次にコード署名に利用する鍵ペア（証明書）およびその検証に必要な証明書を
インポートします．まず，コード署名に利用する鍵ペアをインポートします．

<code>
% pk12util -i /path_to_keypair/object-signing-keypair.p12 -d .
</code>

このとき，コード署名証明書取得時に設定したパスフレーズを入力する必要が
あります．Verisign から発行されたコード署名証明書には，検証パスを確立す
るために必要な証明書がすべて含まれています．そのため，証明書DBで信頼設
定のみ実施すれば，@signtool@ で署名に利用できるようになります．以下追加
された証明書の確認方法です．

<code>
% certutil -L -d .

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

National Institute of Informatics の VeriSign, Inc. ID      u,u,u
VeriSign Class 3 Public Primary Certification Authority - G5 - VeriSign, Inc. ,,   
VeriSign Class 3 Code Signing 2010 CA - VeriSign, Inc.       ,,   
Verisign Class 3 Public Primary Certification Authority      ,,   
</code>

この状態では証明書を発行したCAが信頼されていないため，利用できません．

<code>
% certutil -V -u J -d . -n "National Institute of Informatics の VeriSign, Inc. ID"
certutil: certificate is invalid: Issuer certificate is invalid.
</code>

信頼設定は -M オプションでマークを設定します．

<code>
% certutil -M -t C,C,C -d . -n "Verisign Class 3 Public Primary Certification Authority"
% certutil -M -t C,C,C -d . -n "VeriSign Class 3 Code Signing 2010 CA - VeriSign, Inc."
% certutil -M -t C,C,C -d . -n "VeriSign Class 3 Public Primary Certification Authority - G5 - VeriSign, Inc."
</code>

以下は信頼設定の確認結果です．

<code>
 % certutil -L -d .

Certificate Nickname                                         Trust Attributes
                                                             SSL,S/MIME,JAR/XPI

National Institute of Informatics の VeriSign, Inc. ID      u,u,u
VeriSign Class 3 Public Primary Certification Authority - G5 - VeriSign, Inc. C,C,C
Verisign Class 3 Public Primary Certification Authority      C,C,C
VeriSign Class 3 Code Signing 2010 CA - VeriSign, Inc.       C,C,C
</code>

この状態で，コード署名証明書の有効性について確認します．

<code>
% certutil -V -u J -d ./ -n "National Institute of Informatics の VeriSign, Inc. ID"
certutil: certificate is valid
</code>

以上で@keystore@の設定は完了です．もし，PKCS12 ファイルに検証パスの証明
書が含まれていない場合は，ベンダーのサイトから証明書をダウンロードし，
個別に追加することもできます．証明書をネットワーク経由で取得する際には
別メディアで取得したフィンガープリントの値を確認するなど，慎重に確認し
てください．

以下署名付きブラウザ拡張機能の具体的な生成例です．

<code>
% ./script/signxpi.sh ./keystore trusttools ./trusttools https://test-ds.gakunin.nii.ac.jp/trusttools/providers.json https://gakunin.kyoto-su.ac.jp _redirect_user_idp ds.gakunin.nii.ac.jp
</code>

テスト環境の例は以下のとおりです．

<code>
% ./script/signxpi.sh ./keystore trusttools ./trusttools https://gakunin.example.com/trusttools/providers.json https://gakunin.example.com/idp/ _redirect_user_idp gakunin.example.com
</code>

コマンドを実行すると，@trusttools.xpi@ という署名済みの XPI ファイルが
コマンドを実行したディレクトリに生成されます．生成された XPI ファイルに
は，オプションに指定したデフォルト値が設定されています．生成したファイ
ルを @files@ ディレクトリ以下に格納したい場合は，以下のように
@xpi_file_prefix@ を設定します．

<code>
% ./script/signxpi.sh ./keystore ./files/trusttools ./trusttools https://gakunin.example.com/trusttools/providers.json https://gakunin.example.com/idp/ _redirect_user_idp gakunin.example.com
</code>


h5. フェデレーションに参加しているすべての機関用に署名済みブラウザ拡張
機能を生成する方法

@signxpi.sh@ で指定するデフォルトの IdP (@idp_entity_id@) は，組織によっ
て異なっています．そのため，XPI ファイルは組織ごとに別々にデフォルト値
を設定したものを作成し，組織ごとに配布するのがユーザにとっては利用しや
すくなります．Trust Tools では，フェデレーションのメタデータファイルか
ら，自動的にすべての組織のための署名済みブラウザ拡張機能を生成するスク
リプト @mdsignxpi.pl@ を提供しています．@metadata@ 以外のオプションは，
すべて @signxpi.sh@ と共通です．

<code>
% perl ./script/mdsignxpi.pl metadata keystore_path xpi_file_prefix xpi_path providers_uri idp_cookie_name_for_ds ds_domainname
</code>

* @metadata@: フェデレーションのメタデータファイルのパスを指定します．

@mdsignxpi.pl@ は，メタデータ内に記載された @entityId@ の値を用いて自動
的に署名済み XPI ファイルを生成します．

以下具体的な生成例です．

<code>
% perl ./script/mdsignxpi.pl ./files/gakunin-metadata.xml ./keystore ./files/trusttools ./trusttools https://test-ds.gakunin.nii.ac.jp/trusttools/providers.json _redirect_user_idp ds.gakunin.nii.ac.jp
</code>

テスト環境の例は以下のとおりです．

<code>
% perl ./script/mdsignxpi.pl ./files/metadata.xml ./keystore ./files/trusttools ./trusttools https://gakunin.example.com/trusttools/providers.json _redirect_user_idp gakunin.example.com
</code>


結果として以下のようなファイル名の署名済みのXPIファイルが @files@ ディ
レクトリ内にメタデータ内のIdPごとに生成されます．

<code>
...
trusttools.idp.nii.ac.jp.xpi
trusttools.gakunin.kyoto-su.ac.jp.xpi
...
</code>

h4. 2. 署名済みブラウザ拡張機能の公開

Providerリストと同様に署名済みブラウザ拡張機能を公開する必要があります．
基本的にはProviderリストの公開と同じですが，以下に例を示しておきます．

学認DSで公開する場合
<code>
% perl #{root}/script/mdsignxpi.pl #{root}/files/gakunin-metadata.xml #{root}/keystore trusttools #{root}/trusttools https://test-ds.gakunin.nii.ac.jp/trusttools/providers.json _redirect_user_idp ds.gakunin.nii.ac.jp
% scp #{root}/files/trusttools.*.xpi username@ds.gakunin.nii.ac.jp:/var/www/html/trusttools/
</code>

テストDSで公開する場合
<code>
% perl #{root}/script/mdsignxpi.pl #{root}/files/metadata.xml #{root}/keystore trusttools #{root}/trusttools https://gakunin.example.com/trusttools/providers.json _redirect_user_idp gakunin.example.com
% scp #{root}/files/trusttools.*.xpi username@gakunin.example.com:/var/www/html/trusttools/
</code>

というコマンドを実行することになります．ただし，SSH は公開鍵によりパス
フレーズなしで認証可能にしておく必要があります．

後は，@config/schedule.rb@ を編集し，@whenever@ コマンドで @crontab@ に反映します．

<code>
% vi config/schedule.rb
# publish browser extension
every 1.days do
  set :output, :standard
  command "perl #{root}/script/mdsignxpi.pl #{root}/files/metadata.xml #{root}/keystore trusttools #{root}/trusttools https://gakunin.example.com/trusttools/providers.json _redirect_user_idp gakunin.example.com"
  set :output, "#{root}/log/cron_log.log"
  command "scp #{root}/files/trusttools.*.xpi username@gakunin.example.com:/var/www/html/trusttools/"
end

% whenever
0 0 * * * /bin/bash -l -c 'perl /Users/akiyama/Documents/devel/projects/trusttools/script/mdsignxpi.pl /Users/akiyama/Documents/devel/projects/trusttools/files/metadata.xml /Users/akiyama/Documents/devel/projects/trusttools/keystore trusttools /Users/akiyama/Documents/devel/projects/trusttools/trusttools https://gakunin.example.com/trusttools/providers.json _redirect_user_idp gakunin.example.com'

0 0 * * * /bin/bash -l -c 'scp /Users/akiyama/Documents/devel/projects/trusttools/files/trusttools.*.xpi username@gakunin.example.com:/var/www/html/trusttools/ >> /Users/akiyama/Documents/devel/projects/trusttools/log/cron_log.log 2>&1'

## [message] Above is your schedule file converted to cron syntax; your crontab file was not updated.
## [message] Run `whenever --help' for more options.
% whenever -w
</code>
